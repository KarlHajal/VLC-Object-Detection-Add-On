function descriptor()
    return {
        title = "Object Detector";
        version = "0.1";
        decription = [[ 
Object Detector.

Object Detector is a VLC extension that allows a user to search for objects in a video file.
        ]];
        capabilities = {"menu"}
    }
end

-- activate() : called when the extension is activated from within VLC
function activate()
    vlc.msg.info("Object Detector: activate() setting up variables")
    USER = os.getenv("USER") -- User environment variable to be used to access the absolute path to the extension. 
    local_directory = "/home/" .. USER .. "/.local/share/vlc/lua/extensions/" -- Absolute path to the extension.
    data_directory = "object_detector_data/" -- Directory containing all extension related assets.
    object_detection_output = "object_detection_output.txt" -- File that is written by the object detection Python script at the end of its execution.
    pid_file_name = "object_detection_pid.pid" -- File where the pid of an instance  of the Python script is stored. It is used to be able to halt the process.
    
    vlc.msg.info("Object Detector: activate() calling create dialog")
    create_dialog()
end

-- deactivate() : called when the extension is deactivated from within VLC
function deactivate()
    vlc.msg.info("Object Detector: deactivate() calling close")
    close()
    vlc.msg.info("Object Detector: deactivate() deactivating")
    vlc.deactivate()
end

-- close() : called when the extension is closed by the user
-- deletes all the temporary files that are used to display data 
-- or to relay messages between the python script and the extension
-- then deactivates the extension
function close()
    -- Delete the Python script's output file
    vlc.msg.info("Object Detector: close() removing " .. local_directory .. data_directory .. object_detection_output)
    os.remove(local_directory .. data_directory .. object_detection_output)
    
    -- Delete the image that was generated by the Python script
    if result_frame then
        vlc.msg.info("Object Detector: close() removing " .. local_directory .. data_directory .. "frame" + result_frame + ".jpg")
        os.execute(local_directory .. data_directory .. "frame" + result_frame  + ".jpg")
    end
    
    -- Delete the file containing the pid of the instance of the Python script
    vlc.msg.info("Object Detector: close() removing " .. local_directory .. data_directory .. pid_file_name)
    os.remove(local_directory .. data_directory .. pid_file_name)
    
    -- Deactivate the extension
    vlc.msg.info("Object Detector: close() calling deactivate")
    vlc.deactivate()

    vlc.msg.info("Object Detector closed")
end

function meta_changed()
end

-- create_dialog() : creates the dialog containing the initial widgets
function create_dialog()
    vlc.msg.info("Object Detector: create_dialog() creating dialog")

    dlg = vlc.dialog(descriptor().title)

    -- Object name text input
    dlg:add_label("<b>Search for Object:</b>", 1, 1, 1, 1)
    object_name = dlg:add_text_input("", 1, 2, 3, 1)
    
    -- Start time for search text input
    dlg:add_label("<b>Start Time:</b>",1, 3, 1, 1)
    start_time_hours_text = dlg:add_text_input("0", 1, 4, 1, 1)
    dlg:add_label("<b>h</b>", 2, 4, 1, 1)
    start_time_minutes_text = dlg:add_text_input("0", 3, 4, 1, 1)
    dlg:add_label("<b>m</b>", 4, 4, 1, 1)
    start_time_seconds_text = dlg:add_text_input("0", 5, 4, 1, 1)
    dlg:add_label("<b>s</b>", 6, 4, 1, 1)
    
    -- Button to initiate the search
    dlg:add_button("Search", click_SEARCH, 1, 5, 1, 1)
    
    -- Check box that allows the user to halt an ongoing search
    -- It is used instead of a button because api limitations meant 
    -- that a button couldn't do the job
    stop_check_box = dlg:add_check_box("Stop", false, 3, 5, 1, 1)
    
    -- Reset button that returns everythin back to the initial state
    dlg:add_button("Reset", click_RESET, 5, 5, 1, 1)
    result_label = dlg:add_label("<b> </b>", 1, 6, 1, 1)
    
    -- Image that displays either a search's result or the logo
    dlg:add_image(local_directory .. data_directory .. "logo.png", 1, 7, 3, 3)

    vlc.msg.info("Object Detector: create_dialog() dialog created")
end

-- click_SEARCH() : called when the 'Search' button is clicked
-- creates a coroutine of the start_object_search method which is used to keep checking if
-- the user is requesting for the search to stop, which is a must since a search can sometimes
-- be a very lengthy and costly operation
function click_SEARCH()
    -- Create the search coroutine
    co = coroutine.create(start_object_search)
    
    -- The coroutine is allowed to resume only if the user hasn't checked the stop check box
    while not (stop_check_box:get_checked() or coroutine.status(co) == "dead") do
        coroutine.resume(co)
    end

    -- If the user requested that the search be halted, the click_STOP() method is called.
    -- This means that the search process is killed.
    if stop_check_box:get_checked() then
        stop_check_box:set_checked(false)
        click_STOP()
    end
end

function start_object_search()
    -- If no video file is opened in vlc, reset and return
    if not vlc.input.is_playing() then
        vlc.msg.info("start_object_search() : no video file is opened, reset and return") 
        click_RESET()
        return
    end

    -- Set the displayed text to show the user that the search is underway
    result_label:set_text("<b>Searching ...</b>")
    
    -- Delete the output file in case a previous search's result persists
    local f = io.open(local_directory .. data_directory .. object_detection_output, "r")
    if f ~= nil then
        vlc.msg.info("start_object_search() : deleting object detection output file that is already present")
        io.close(f)
        os.remove(local_directory .. data_directory .. object_detection_output)
    end
    
    -- Get the currently playing video file's directory
    local item = vlc.input.item()
    local video_file_directory = item:uri()
    video_file_directory = string.gsub(video_file_directory, '^file://', '')
    video_file_directory = string.gsub(video_file_directory, '%%20', '\\ ')
    video_file_directory = string.gsub(video_file_directory, '%%27', '\\\'')

    object_detection_script_directory = local_directory .. data_directory .. "video_object_detection.py"

    -- Turn the numbers entered by the users in hr:min:sec format into seconds
    local time = tostring(tonumber(start_time_hours_text:get_text())*3600 + tonumber(start_time_minutes_text:get_text())*60 + tonumber(start_time_seconds_text:get_text()))

    -- Call the python script that does the object detection with the proper arguments, make it run in the background and store its pid in a file
    vlc.msg.info("start_object_search() : starting the search for " .. object_name:get_text() .. " in " .. video_file_directory .. " starting at time " .. tostring(time) .. "seconds.")

    cmd = "python3 " .. object_detection_script_directory .. " " .. video_file_directory .. " " .. object_name:get_text() .. " " .. time .. " 0 & echo $! > " .. local_directory .. data_directory .. pid_file_name
    vlc.msg.info("start_object_search() : running command " .. cmd)
  
    os.execute(cmd)
    
    coroutine.yield()
    -- The following is necessary to give the user the ability to halt an ongoing search since it can
    -- sometimes be very lengthy and costly.
    -- Unless the object detection script has generated an output file, it keeps yielding to the click_SEARCH() 
    -- function to give it a chance to check if the user has requested that the search stops.
    f = io.open(local_directory .. data_directory .. object_detection_output, "r")
    while f == nil do
        coroutine.yield()
        f = io.open(local_directory .. data_directory .. object_detection_output, "r")
    end
    io.close(f)
   
    -- Since the execution is done at that point, delete the file containing the previously running process' pid
    os.remove(local_directory .. data_directory .. pid_file_name)
    
    --
    vlc.msg.info("start_object_search() : calling display results")
    display_results()
end

-- display_results() : displays the results obtained from the output of the object detection python script
function display_results()
    local file = io.open(local_directory .. data_directory .. object_detection_output, "r")
    if file ~= nil then
        vlc.msg.info("display_results() : Reading file " .. local_directory .. data_directory .. object_detection_output)
        
        -- Read the first line of the output file; if all went well it should be the number of the frame
        -- where the object was found, otherwise it'll be an error message showing either that the object
        -- simply wasn't found, or that there was some error that did not allow the script to run properly
        result_frame = file:read "*line"
        
        -- If it turned out to be a number then the object was found
        if tonumber(result_frame) ~= nil then
            result_time = file:read "*line" -- Time at which the object was found in the video file
            result_label:set_text("<b>Object Found at time " .. result_time .. "</b>") -- Display the time to the user
            dlg:add_image(local_directory .. data_directory .. "frame".. result_frame .. ".jpg", 1,7,3,3) -- Show the frame with the bounding boxes to the user
            gotoframe_button = dlg:add_button("Go To Frame", click_JUMP, 3, 6, 1, 1) -- Add a button that allows the user to jump to the frame found to be containing the object
        -- else it's an error message which is displayed to the user
        else
            result_label:set_text("<b>" .. result_frame .. "</b>") -- Display Error message passed from Python script
        end
            
        io.close(file)
        os.remove(local_directory .. data_directory .. object_detection_output)
    else
        -- If there is no output file, then there was no result
        result_label:set_text("<b>No Result</b>")
    end
end

-- click_STOP() : halts the execution of the object detection Python script by acquiring its process' pid and killing it
function click_STOP()
    vlc.msg.info("click_STOP() : stopping the script's execution")
    
    vlc.msg.info("click_STOP() : Opening file " .. local_directory .. data_directory .. pid_file_name)
    local f = io.open(local_directory .. data_directory .. pid_file_name, "r")
    if f ~= nil then
        vlc.msg.info("click_STOP() : Reading the file to acquire the process' pid")
        process_pid = f:read "*line"
        io.close(f)

        vlc.msg.info("click_STOP() : Deleting file " .. local_directory .. data_directory .. pid_file_name)
        os.remove(local_directory .. data_directory .. pid_file_name)
        
        vlc.msg.info("click_STOP() : Killing process with pid " .. process_pid)
        os.execute("kill -9 " .. process_pid)
    else
        vlc.msg.info("Could not open file " .. local_directory .. data_directory .. pid_file_name)
    end

    -- Clean up the UI
    if result_label:get_text() == "<b>Searching ...</b>" then
        dlg:add_image(local_directory .. data_directory .. "logo.png", 1,7,3,3)
        if gotoframe_button then
            dlg:del_widget(gotoframe_button)
        end
    end

    -- Show the user that the search was successfully halted
    result_label:set_text("<b>Stopped Search</b>")
    -- Reset the check box's state to unchecked
    stop_check_box:set_checked(false)
end

-- click_RESET() : resets the UI to its initial state and deletes all temporary files
--                 that store information about the previous search, if there was one
function click_RESET()
    vlc.msg.info("click_RESET() : Object Detector Resetting GUI")
    dlg:add_image(local_directory .. data_directory .. "logo.png", 1,7,3,3)
    result_label:set_text("<b></b>")
    
    if gotoframe_button then 
        dlg:del_widget(gotoframe_button)
    end

    vlc.msg.info("click_RESET() : Deleting " .. local_directory .. data_directory .. object_detection_output)
    os.remove(local_directory .. data_directory .. object_detection_output)
    
    vlc.msg.info("click_RESET() : Deleting " .. local_directory .. data_directory .. pid_file_name)
    os.remove(local_directory .. data_directory .. pid_file_name)
    
    if result_frame then
        vlc.msg.info("click_RESET() : Deleting " .. local_directory .. data_directory .. "frame" .. result_frame .. ".jpg")
        os.remove(local_directory .. data_directory .. "frame" + result_frame + ".jpg")
    end
end

-- click_JUMP() : allows the user to jump instantly to the frame where the object was found following a successful search
function click_JUMP()
    -- Change the time from hh:mm:ss format to seconds
    local time_in_s = timestring_to_seconds(result_time)
	
    vlc.msg.info("click_JUMP() : Object Detector jumping to time " .. result_time .. " or " .. tostring(time_in_s) .. " in seconds.")
    local input_vid=vlc.object.input()
    if input_vid then 
        -- set the vlc "time" variable to the time in seconds * 10^6 according to VLC's implementation
        vlc.var.set(input_vid, "time", time_in_s*1000000) 
    end
end

-- timestring_to_seconds() : transforms a string in the hh:mm:ss format into a number with its equivalent value in seconds
function timestring_to_seconds(timestring) 
    -- split the hh:mm:ss string at the ':' character
    timestring = split_string(timestring, ":")
    -- get the value in seconds
    return tonumber(timestring[1])*3600 + tonumber(timestring[2])*60 + tonumber(timestring[3])
end

-- split_string() : splits a string according to a delimiter pattern and places each bit in a table
function split_string(s, d) -- s -> string , d -> delimiter pattern
    local t={}
    local i=1
    local ss, j, k
    local b=false
    while true do
        j,k = string.find(s,d,i)
        if j then
            ss=string.sub(s,i,j-1)
            i=k+1
        else
            ss=string.sub(s,i)
            b=true
        end
        table.insert(t, ss)
        if b then break end
    end
    return t
end

